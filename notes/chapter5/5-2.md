# 字符串匹配

## BF算法

暴力匹配算法(Brute Force)

1. 在主串A中查找模式串B，A长度为n, B长度为m
2. 我们在主串中，检查起始位置分别是 0、1、2…n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的
![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20191118-220023@2x.png)

## RK算法

1. BF的优化版，通过预先对主串中的n-m+1个子串求哈希值，然后再比较哈希值。

## BM算法

1. 坏字符规则
![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20191119-135337@2x.png)

2. 好后缀规则
    - 情况1: 模式串中存在与好后缀匹配的字串
    ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20191119-135451@2x.png)

    - 情况2：模式串中存在与*好后缀的后缀*匹配的前缀字串
    ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20191119-135500@2x.png)

---

## KMP算法

1. 概念：前缀、后缀、相同前缀后缀的最大长度(后面简称，最大公共长)
    - abcdef的前缀: a, ab, abc, abcd
    - abcdef的后缀: f, ef, def, bcdf
    - abcdef的最大公共长: 0
    - ababa的前缀: a, ab, aba, abab
    - ababa的后缀: a, ba, aba, baba
    - ababa的最大公共长: 3(这里就是aba)
2. 利用相同前缀后缀的最大长度（公共最大长）对匹配过程进行优化
    - 将模式串移动一定的位置，使得模式串中的好前缀子串中的最大公共长的前缀字串(s1)，与主串中的好前缀子串中的最大公共长的后缀子串(s2)匹配。如下图

    ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20191119-163020@2x.png)
