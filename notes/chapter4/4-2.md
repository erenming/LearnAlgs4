# 有向图

- 定义：一幅有方向的图是由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点
- 有向边：由第一个顶点**指出**并**指向**第二个顶点
- 出度：某顶点指出的边的总数
- 入度：指向某顶点的边的总数
- 有向路径：由一系列顶点组成，对于其中的每个顶点都存在一条有向边从它指向序列的下一个顶点
- 有向环：一条至少含有一条边且起点和终点相同的有向路径
- 表示：邻接表
- 取反：返回一个副本，但其中所有边的方向反转
- 可达性：
    1. 单点可达性
        - 给定一幅有向图和一个起点s, 回答“是否存在一条从s到给定顶点v的有向路径？”等类似问题
    2. 多点可达性
        - 给定一幅有向图和顶点的集合, 回答“是否存在一条从集合中的任意顶点到达给定顶点v的有向路径？”等类似问题
    3. 实现：使用深度优先搜索算法
- 有向环检测：通过dfs, 一旦找到一条有向边v -> w且w已存在于栈(一个数组)中，就找到了一个环
- 应用：
    1. 标记-清除的垃圾收集
        - 为每个对象保留一个位置
        - 并周期性地运行一个类似于`DirectedDFS`的有向图可达性算法来标记所有可被访问到的对象，然后清理所有对象（回收未被标记的对象）
    2. 有向图的寻路
        - 单点有向路径
        - 单点最短有向路径
    3. 调度问题：
        - 优先级限制下的调度问题：给定一组任务根据优先级(诸如任务的执行时间，时耗等)安排它们的执行顺序。例如大学课程安排
        - 拓扑排序：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素
        - 解决步骤：
            1. 说明任务和优先级条件
            2. 不断检测并去除有向图中的所有环，以确保存在可行方案
            3. 使用拓扑排序解决调度问题
    4. 顶点的深度优先次序与拓补排序：
        - 基本思想：
            1. 深度优先搜索正好只会访问每个顶点一次，将访问记录保存在相关数据结构中
        - 3种排序：
            1. 前序：在递归调用之前将顶点加入队列
            2. 后序：在递归调用之后将顶点加入队列
            3. 逆后序：在递归调用之后将顶点压入栈
        - 一幅有向无环图的拓扑结构即为所有顶点的**逆后序**排列(记住即可)
- 强连通性：
    1. 如果两个顶点是互相可达的，则称它们为强连通的；如果一幅有向图中的任意两个顶点都是强连通的，则称这幅有向图也是强连通的
    2. 性质：
        - 自反性：任意顶点v和自己都是强连通的
        - 对称性：如果v和w是强连通的，那么w和v也是强连通的
        - 传递性：如果v和w是强连通的且w和x也是强连通的，那么v和x也是强连通的
    3. 强连通分量：由互相均为强连通的顶点的*最大子集*组成的集合
        ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20190625-214540@2x.png)
    4. 应用场景：突出了相互关联的几组顶点
        - 网络：顶点为网页、边为超链接。连通分量可以将网页分为多个大小可接受的部分
        - 软件：顶点为模块，边为引用。
    5. Kosaraju算法(记住即可)：
        1. 在给定的一幅有向图G中，使用DepthFirstOrder来计算它的反向图G^R的逆后序排列
        2. 在G中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的顺序来访问所有未被标记的顶点
        3. 在构造函数中，所有在同一递归dfs()调用中被访问到的顶点都在同一个*强连通分量*中，将它们按照和CC相同的方式识别出来
    6. 评价：
        1. 预处理的时间和空间**与V+E成正比**且支持**常数**时间的有向图强连通性的查询
            
- 两点的可达性：（暂无最佳）
    1. 传递闭包：
        ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20190625-223035@2x.png)
        - 有向图G的传递闭包是由相同的一组顶点组成的另一幅有向图，在传递闭包中存在一条从v指向w的边当且仅当在G中w是从v可达的

        ```java
        public class TransitiveClosure {
            private DirectedDFS[] tc;   // tc[v] = reachable from v

            public TransitiveClosure(Digraph G) {
                tc = new DirectedDFS[G.V()];
                for (int v = 0; v < G.V(); v++) {
                    tc[v] = new DirectedDFS(G, v);
                }
            }

            public boolean reachable(int v, int w) {
                return tc[v].marked(w);
            }
        }
        ```

        - 构造消耗大
            - 空间：O(n2)
            - 时间：O(n)