# 散列表

- 用算术操作将键转化为数组的索引来访问数组中的键值对：
    1. 用散列函数将被查找的键转化为数组中的一个索引
    2. 处理碰撞冲突
- 散列函数
    1. 正整数：
        - 常用*除留余数法*，选择大小为**素数**M的数组。（ps.若不用素数，可能会导致无法均匀地散列散列值）
    2. 浮点数：
        - 将键表示为二进制后再使用*除留余数法*
    3. 字符串：
        - 将它当作大整数，再用*除留余数法*
    4. 组合键：
        - 键的类型含有多个整数变量，可和String类型一样将他们混合起来
    5. 软缓存：
        - 通常需要将每个键的散列值缓存起来，以避免重复计算耗时
    6. 优秀的散列函数条件：
        - 一致性：等价的键必然产生相等的散列值
        - 高效性：计算简便
        - 均匀性：均匀地散列所有的键
- 基于拉链法的散列表
    ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20190410-214220@2x.png)

    1. 定义：将大小为M的数组中的每个元素指向一条链表，链表中的每个节点都存储了散列值为该元素的索引的键值对
    2. 无论键在各个链表中的分布如何，链表的平均长度肯定是N/M
        - N: 键值对的数量
        - M: 散列表的大小
    3. 查找：

        ```java
        public Value get(Key key)
        {  return (Value) st[hash(key)].get(key);  }
        ```

        - 根据散列值找到对应的链表
        - 沿着链表顺序查找相应的键
    4. 删除：根据散列值找到链表，调用链表的delete()方法
    5. 插入：根据散列值找到链表，调用链表的put()方法
    6. 评价：
        - 未命中查找和插入操作所需的比较次数为~N/M
- 基于线性探测法的散列表
    1. 开放地址散列表：基于用大小为M的数组保存N个键值对，其中M>N，依靠数组中的空位解决冲突的策略的所有方法的统称
    2. 线性探测法：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表的下一个位置（将索引值+1）。产生三种结果：
        1. 命中，该位置的键和被查找的键相同
        2. 未命中，键为空
        3. 继续查找，该位置的键与被查找的不同
    3. 探测：检查一个数组位置是否由被查找的键的操作
    4. 使用率：a = N/M
        - 这里我们保持使用率在`1/8 ~ 1/2`之间
    5. 删除：需要将簇中被删除键的右侧的所有键重新插入散列表
    6. 键簇：元素在插入数组后聚集成的一组*连续*的条目
        - 簇越长探测次数越多，所以簇越短小性能越好
        - 根据命题M, 通常取a <= 1/2, 较为合适
    7. 评价：
        - 查找和插入操作性能趋向O(1)
        - 不足：
            - 每种类型的键都需要一个优秀的散列函数
            - 性能保证来自于散列函数的质量
            - 散列函数的计算可能复杂而昂贵
            - 难以支持有序性相关的符号表操作