- 符号表：一张抽象的表，将信息（值）存储在其中，然后按照指定的键来搜索并获取这些信息
- 大O符号：又称渐进符号
- 有序符号表：保持键有序的符号表
- 无序链表中的顺序查找
- 有序数组中的二分查找：
    1. 使用一对平行的数组，一个储存键一个储存值
- 二叉查找树
    - 定义：是一棵二叉树，其中每个节点都含有一个Comparable的键（以及相关联的值）且每个节点的键都大于其左子树中的任意节点的键而小于右子树的任意节点的键
    - 表示：
        1. 节点：一个键、一个值、一条左链接、一条右链接和一个节点计数器（1（自身）+子树中的所有节点数）
    - 查找：
        1. 如果树是空的，则查找未命中
        2. 如果被查找的键和根节点的键相等，查找命中，否则我们就（递归地）在适当的子树中继续查找
        3. 如果被查找的键小于就选择左子树，较大则选择右子树
    - 插入：
        1. 如果树是空的，就返回一个含有该键值对的新节点
        2. 如果被查找的键小于根节点的键，我们会继续在左子树中插入该键，否则在右子树插入该键
    - 删除：用被删除节点x的后继节点填补它的位置
        1. 将指向即将被删除的节点的链接保存为t
        2. 将x指向它的后继节点min(t.right)
        3. 将x的右链接指向deleteMin(t.right)，也就是在删除后所有节点仍然都大于x.key的子二叉树
        4. 将x的左链接设为t.left
    - 最小键（最大键同理）
        1. 如果根节点的左链接为空，那么一棵二叉查找树中最小的键就是根节点
        2. 如果左链接非空，那么树中最小键就是左子树中的最小键
    - 向下取整（向上取整同理）
        1. 如果给定的键key小于BST的根节点的键，那么小于等于key的最大键floor(key)一定在根节点的左子树中
        2. 如果给定的键key大于BST的根节点，那么只有当根节点右子树中存在小于等于key的节点时，小于等于key的最大键才会出现在右子树中，否则根节点就是小于等于key的最大键
    - 选择排名为k的键
        1. 如果左子树中的节点数t大于k，那么我们就继续在左子树中查找排名为k的键
        2. 如果t等于k，我们就返回根节点中的键
        3. 如果t小于k，我们就在右子树中查找排名为(k-t-1)的键
    - 范围查找
        1. 中序遍历：左->根->右
        ```java
            private void print(Node x)
            {
                if (x == null) return;
                print(x.left);
                StdOut.println(x.key);
                print(x.right);
            }
        ```
        2. 使用Queue来收集符合条件的键
    - 树的高度：树中任意节点的最大深度
    - 随机键构造的二叉查找树的平均高度为树中节点数的对数级别
    - 优缺点：
        - 缺点：
            1. 性能依赖于其中的键的分布足够随机以消除长路径

---
- 平衡查找树
    - 一个节点保存多个键
        1. 2-节点：含有一个键和两条链接
        2. 3-节点：含有两个键和3条链接，每条链接对应着其中保存的键所分割产生的一个**区间**
    - 2-3查找树：空树或由2-节点和3-节点组成
    - **完美平衡**的2-3查找树：树中的所有**空链接**到根节点的距离都是相同的
    - 查找：
        1. 一般化BST的查找
        2. 首先将它和根节点比较，如果它与其中任意一个相等，查找命中
        3. 否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找
        4. 如果这个链接是一个空链接，查找未命中
    - 插入：
        - 向2-节点中插入新键
            1. 同BST步骤，但遇到2-节点时，将其替换为一个3-节点
        - 向一个只含有一个3-节点的树中插入新键
            1. 临时将新建存入该节点中，使之成为一个4-节点
            2. 分解，再将其转换为一棵由3个2-节点组成的2-3树，其中一个节点（根）含有中键，一个含有最小者（与根的左链接相连），一个含有最大者（与根的右链接相连）
        - 向一个父节点为2-节点的3-节点中插入新键
            1. 临时将新建存入该节点中，使之成为一个4-节点
            2. 将中键移至原来的父节点中，使之转换为一个3-节点，相当于将原3-节点的一条链接替换为新父节点中的原中键左右两边的两条链接，并分别指向两个新的2-节点
        - 向一个父节点为3-节点的3-节点中插入新键
            1. 临时将新建存入该节点中，使之成为一个4-节点
            2. 不断向上分解临时的4-节点并将中键插入更高层的父节点，直至遇到一个2-节点并将它替换为一个不需要继续分解的3-节点，或者到达3-节点的根
            3. 若真到达了根节点，我们将临时的4-节点分解为3个2-节点，并使得树高加1
        - 备注
            1. 上述情况所发生的变换都是局部的：除了相关的节点和链接之外不必修改或检查树的其他部分
            2. 而这种局部变换不会影响树的全局有序性和平衡性
    - 优缺点：
        优点：
            1. 最坏情况下人能保持平衡，从而仍有较好的性能
        缺点：
            1. 实现复杂，且产生的额外开销可能会使代码比标准的二叉查找树更慢
----
- 红黑二叉查找树
    - 基本思想：用标准的二叉查找树（完全由2-节点构成）和一些额外的信息来表示2-3树
    - 拥有BST中简洁高效的查找方法和2-3树中搞笑的平衡插入算法
    - 构成：
        1. 红链接：将两个2-节点连接起来构成一个3-节点（ 将3-节点表示为一条**左斜**的红色链接相连的两个2-节点）
        2. 黑链接：2-3树中的普通链接
    - 定义：
        1. 红链接均为左链接
        2. 没有任何一个节点同时和两条红链接相连
        3. 该树是**完美黑色平衡**的，即任意空链接到根节点的路劲上的**黑链接**数量相同
    - 旋转：
        1. when?某些操作中，出现红色右链接或者两条连续的红链接
        2. 左旋转：将一条红色的右链接转化为左链接，可理解为将两个键中根从较小者变为较大者
        3. 右旋转：与左旋转同理
        4. 保证了红黑树的两个性质：有序性和完美平衡性
    - 插入：
        1. 向单个2-节点插入新键
            - 若新键小于老键，则新增一个红色节点，新的红黑树等同一个3-节点
            - 若新键大于老键，则新增一个红色节点，产生红色右链接，然后进行一侧左旋转
        2. 向树底部的2-节点插入新键（若其父节点是一个2-节点）
            -  如果指向新节点的是父节点的左链接，那么父节点就直接成为了一个3-节点
            - 如果指向新节点的是父节点的右链接，则需进行一次左旋转
        3. 向一棵双键树（即一个3-节点）中插入新键
            - 新键大于原树中的两个键，则被连接到3-节点的右链接，然后将两条链接由红变黑
            - 新键小于原树中的两个键，则产生连续的两条红链接，然后需将上层的红链接右旋转，即得到第一种情况
            - 新键介于原树中的两个键之间，则产生一左一右的两条连续红链接，然后需将下层红链接左旋转，则得到第二种情况
        4. 向树底部的3-节点插入新键
            - 同第3点情况，转化结束后，会使中节点的链接变红，这相当于在父节点中继续插入一个新键
            - 总结来看，我们首先创建一个临时的4-节点，将其分解并将红链接由中间键传递给它的父节点。重复这个过程知道遇到一个2-节点或根节点

    - 备注：
        1. 颜色转换，我们除了将子节点的颜色由红变黑，同时还要将父节点的颜色由黑变红