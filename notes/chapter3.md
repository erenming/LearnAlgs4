- 平衡查找树
    - 一个节点保存多个键
        1. 2-节点：含有一个键和两条链接
        2. 3-节点：含有两个键和3条链接，每条链接对应着其中保存的键所分割产生的一个**区间**
    - 2-3查找树：空树或由2-节点和3-节点组成
    - **完美平衡**的2-3查找树：树中的所有**空链接**到根节点的距离都是相同的
    - 查找：
        1. 一般化BST的查找
        2. 首先将它和根节点比较，如果它与其中任意一个相等，查找命中
        3. 否则我们就根据比较的结果找到指向相应区间的链接，并在其指向的子树中递归地继续查找
        4. 如果这个链接是一个空链接，查找未命中
    - 插入：
        - 向2-节点中插入新键
            1. 同BST步骤，但遇到2-节点时，将其替换为一个3-节点
        - 向一个只含有一个3-节点的树中插入新键
            1. 临时将新建存入该节点中，使之成为一个4-节点
            2. 分解，再将其转换为一棵由3个2-节点组成的2-3树，其中一个节点（根）含有中键，一个含有最小者（与根的左链接相连），一个含有最大者（与根的右链接相连）
        - 向一个父节点为2-节点的3-节点中插入新键
            1. 临时将新建存入该节点中，使之成为一个4-节点
            2. 将中键移至原来的父节点中，使之转换为一个3-节点，相当于将原3-节点的一条链接替换为新父节点中的原中键左右两边的两条链接，并分别指向两个新的2-节点
        - 向一个父节点为3-节点的3-节点中插入新键
            1. 临时将新建存入该节点中，使之成为一个4-节点
            2. 不断向上分解临时的4-节点并将中键插入更高层的父节点，直至遇到一个2-节点并将它替换为一个不需要继续分解的3-节点，或者到达3-节点的根
            3. 若真到达了根节点，我们将临时的4-节点分解为3个2-节点，并使得树高加1
        - 备注
            1. 上述情况所发生的变换都是局部的：除了相关的节点和链接之外不必修改或检查树的其他部分
            2. 而这种局部变换不会影响树的全局有序性和平衡性
    - 评价：
        - 优点：
            1. 最坏情况下人能保持平衡，从而仍有较好的性能
        - 缺点：
            1. 实现复杂，且产生的额外开销可能会使代码比标准的二叉查找树更慢
----
- 红黑二叉查找树
    - 基本思想：用标准的二叉查找树（完全由2-节点构成）和一些额外的信息来表示2-3树
    - 拥有BST中简洁高效的查找方法和2-3树中搞笑的平衡插入算法
    - 构成：
        1. 红链接：将两个2-节点连接起来构成一个3-节点（ 将3-节点表示为一条**左斜**的红色链接相连的两个2-节点）
        2. 黑链接：2-3树中的普通链接
    - 定义：
        1. 红链接均为左链接
        2. 没有任何一个节点同时和两条红链接相连
        3. 该树是**完美黑色平衡**的，即任意空链接到根节点的路劲上的**黑链接**数量相同
    - 旋转：
        1. when?某些操作中，出现红色右链接或者两条连续的红链接
        2. 左旋转：将一条红色的右链接转化为左链接，可理解为将两个键中根从较小者变为较大者
        3. 右旋转：与左旋转同理
        4. 保证了红黑树的两个性质：有序性和完美平衡性
    - 插入：
        1. 向单个2-节点插入新键
            - 若新键小于老键，则新增一个红色节点，新的红黑树等同一个3-节点
            - 若新键大于老键，则新增一个红色节点，产生红色右链接，然后进行一侧左旋转
        2. 向树底部的2-节点插入新键（若其父节点是一个2-节点）
            - 如果指向新节点的是父节点的左链接，那么父节点就直接成为了一个3-节点
            - 如果指向新节点的是父节点的右链接，则需进行一次左旋转
        3. 向一棵双键树（即一个3-节点）中插入新键
            - 新键大于原树中的两个键，则被连接到3-节点的右链接，然后将两条链接由红变黑
            - 新键小于原树中的两个键，则产生连续的两条红链接，然后需将上层的红链接右旋转，即得到第一种情况
            - 新键介于原树中的两个键之间，则产生一左一右的两条连续红链接，然后需将下层红链接左旋转，则得到第二种情况
        4. 向树底部的3-节点插入新键
            - 同第3点情况，转化结束后，会使中节点的链接变红，这相当于在父节点中继续插入一个新键
            - 总结来看，我们首先创建一个临时的4-节点，将其分解并将红链接由中间键传递给它的父节点，重复这个过程知道遇到一个2-节点或根节点
    - 删除：
        1. 我们不仅要（为了删除一个节点而）构造临时4-节点时沿着查找路径向下进行变换，还要在分解遗留的4-节点时沿着查找路径向上进行变换
    - 性质：
        1. 所有基于红黑树的符号表实现都能保证操作的运行时间为对数级别
    - 备注：
        1. 颜色转换，我们除了将子节点的颜色由红变黑，同时还要将父节点的颜色由黑变红

---

- 散列表
    - 用算术操作将键转化为数组的索引来访问数组中的键值对：
        1. 用散列函数将被查找的键转化为数组中的一个索引
        2. 处理碰撞冲突
    - 散列函数
        1. 正整数：
            - 常用*除留余数法*，选择大小为**素数**M的数组。（ps.若不用素数，可能会导致无法均匀地散列散列值）
        2. 浮点数：
            - 将键表示为二进制后再使用*除留余数法*
        3. 字符串：
            - 将它当作大整数，再用*除留余数法*
        4. 组合键：
            - 键的类型含有多个整数变量，可和String类型一样将他们混合起来
        5. 软缓存：
            - 通常需要将每个键的散列值缓存起来，以避免重复计算耗时
        6. 优秀的散列函数条件：
            - 一致性：等价的键必然产生相等的散列值
            - 高效性：计算简便
            - 均匀性：均匀地散列所有的键
    - 基于拉链法的散列表
        1. 定义：将大小为M的数组中的每个元素指向一条链表，链表中的每个节点都存储了散列值为该元素的索引的键值对
        2. 无论键在各个链表中的分布如何，链表的平均长度肯定是N/M
        3. 查找：
            - 根据散列值找到对应的链表
            - 沿着链表顺序查找相应的键
        4. 删除：根据散列值找到链表，调用链表的delete()方法
        5. 插入：根据散列值找到链表，调用链表的put()方法
        6. 评价：
            - 未命中查找和插入操作所需的比较次数为~N/M
    - 基于线性探测法的散列表
        1. 开放地址散列表：基于用大小为M的数组保存N个键值对，其中M>N，依靠数组中的空位解决冲突的策略的所有方法的统称
        2. 线性探测法：当碰撞发生时（当一个键的散列值已经被另一个不同的键占用），我们直接检查散列表的下一个位置（将索引值+1）。产生三种结果：
            1. 命中，该位置的键和被查找的键相同
            2. 未命中，键为空
            3. 继续查找，该位置的键与被查找的不同
        3. 探测：检查一个数组位置是否由被查找的键的操作
        4. 使用率：a = N/M
        5. 删除：需要将簇中被删除键的右侧的所有键重新插入散列表
        6. 键簇：元素在插入数组后聚集成的一组连续的条目
            - 簇越长探测次数越多，所以簇越短小性能越好
            - 根据命题M, 通常取a <= 1/2, 较为合适
        7. 评价：
            - 查找和插入操作性能趋向O(1)
            - 不足：
                - 每种类型的键都需要一个优秀的散列函数
                - 性能保证来自于散列函数的质量
                - 散列函数的计算可能复杂而昂贵
                - 难以支持有序性相关的符号表操作
---
- 应用：
    - 集合
    - 字典
    - 索引
        1. 用索引来描述一个键和多个值相关联的符号表
        2. 反向索引：用值来查找键
    - 稀疏向量