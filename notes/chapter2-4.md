1. 优先队列
    - API:
        ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20190321-221717@2x.png)
    - 初级实现：
        1. 无序数组：删除最大元素为O(N)
        2. 有序数组：插入元素为O(N)
        3. 无序链表：删除最大元素为O(N)
        4. 有序链表：插入元素为O(N)
    - 堆的实现
2. 二叉堆
    - 在二叉堆数组中，每个元素要保证大于等于另外两个特定位置的元素，以此类推
    - 二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存(不使用数组的第一个位置)
    - 数组a中的位置k，从a[k]向上一层就令k等于k/2, 向下一层则令k等于2k或2k+1
    - 堆的有序化：由于一些操作打跑了堆的状态，然后需要再遍历堆按照要求将堆的状态恢复
        1. 由下至上的堆有序化(上浮)：当某个节点的优先级上升，比它的父节点大

        ```java
        private void swim(int k)
        {
            while (k > 1 && less(k/2, k))  // 节点k比其父节点k/2大
            {
                exch(k/2, k);              // 将两者交换
                k = k/2;
            }
        }
        ```

        2. 由上至下的堆有序化(下沉)：当某个节点的优先级下降，比它的两个子节点或是其中一个子节点更小

        ```java
        private void sink(int k)
        {
            while (2*k <= N)        // 是否还有子节点
            {
                int j = 2*k;
                if (j < N && less(j, j+1)) j++;  // 若存在俩节点，选择较大者
                if (!less(k, j)) break;
                exch(k, j);                     // 若k小于较大的子节点，则交换两者
                k = j;
            }
        }
        ```

    - 插入元素(nlogn)：将新元素加到数组末尾，增加堆大小并让这个元素上浮到合适位置
    - 删除最大元素(nlogn)：删除数组顶端的最大元素，并将数组末尾的元素放到顶端，然后对其下沉到合适位置
    - *索引优先队列*应用举例
        1. 多向归并：将多个有序的输出流归并为一个有序的输出流
3. 堆排序

    ```java
    public static void sort(Comparable[] a)
    {
        int N = a.length;
        for (int k = N/2; k >= 1; k--)  // 跳过大小为1的子堆
            sink(a, k, N);
        while (N > 1)
        {
            exch(a, 1, N--);
            sink(a, 1, N);
        }
    }
    ```

    - 步骤
        1. 堆的构造：将原始数组重新组织安排进一个堆中
        2. 下沉排序：从堆中按递减顺序去除所有元素并得到排序结果
    - 时间复杂度：O(nlogn)
    - 空间复杂度：O(1)
    - 多用于空间有限的系统。由于无法利用缓存，现代系统极少使用