
---
- 有向图：
    - 定义：一幅有方向的图是由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点
    - 有向边：由第一个顶点**指出**并**指向**第二个顶点
    - 出度：某顶点指出的边的总数
    - 入度：指向某顶点的边的总数
    - 表示：邻接表
    - 取反：返回一个副本，但其中所有边的方向反转
    - 可达性：
        1. 单点可达性
        2. 多点可达性
    - 有向环检测：一旦找到一条有向边v -> w且w已存在于栈中，就找到了一个环
    - 应用：
        1. 标记-清除的垃圾收集
        2. 有向图的寻路
        3. 调度问题：
            - 优先级限制下的调度问题：给定一组任务根据优先级(诸如任务的执行时间，时耗等)安排它们的执行顺序
            - 拓扑排序：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素
            - 解决步骤：
                1. 说明任务和优先级条件
                2. 不断检测并去除有向图中的所有环，以确保存在可行方案
                3. 使用拓扑排序解决调度问题
        4. 顶点的深度优先次序与拓补排序：
            - 基本思想：
                1. 深度优先搜索正好只会访问每个顶点一次
                2. 此时，如果将dfs()的参数顶点保存在某种数据结构中，遍历这个数据结构实际上就能访问图中的所有顶点，遍历的顺序取决于这个
                数据结构的性质以及在递归调用之前或之后保存。分为前序，后序，逆后序
            - 一幅有向无环图的拓扑结构即为所有顶点的逆后序排列
    - 强连通性：
        1. 如果两个顶点是互相可达的，则称它们为强连通的；如果一幅有向图中的任意两个顶点都是强连通的，则称这幅有向图也是强连通的
        2. 性质：
            - 自反性
            - 对称性
            - 传递性
        3. 强连通分量：由互相均为强连通的顶点的最大子集组成的集合
        4. 应用：
            - 分类问题：
                1. 例如网络，顶点为网页、边为超链接。连通分量可以将网页分为多个大小可接受的部分
        5. 计算方法:
            - Kosaraju算法：
                1. 在给定的一幅有向图G中，使用DepthFirstOrder来计算它的反向图G^R的逆后序排列
                2. 在G中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的书序来访问所有未被标记的顶点
                3. 在构造函数中，所有在同一递归dfs()调用中被访问到的顶点都在同一个*强连通分量*中，将它们按照和CC相同的方式识别出来
            - 评价：
                1. 预处理的时间和空间**与V+E成正比**且支持**常数**时间的有向图强连通性的查询
                
    - 两点的可达性：
        1. 传递闭包：
            - 有向图G的传递闭包是由相同的一组顶点组成的另一幅有向图，在传递闭包中存在一条从v指向w的边当且仅当在G中w是从v可达的
            
---
- 最小生成树
    - 加权图：是一种为每条边关联一个权值或是成本的图模型
    - 生成树：是图的一棵含有其所有顶点的无环连通子图
    - 最小生成树(MST)：是加权图的一棵权值最小的生成树
    - 切分：是将图的所有顶点分为两个非空且不重叠的两个集合
    - 横切边：是一条连接两个属于不同集合的顶点的边
    - 切分定理：在一幅加权图中，给定任意的切分，它的横切边中的*权重最小者*必然属于图的最小生成树
    - 最小生成树的贪心算法：
        1. 下面的这种方法会将含有V个顶点的任意加权连通图中属于最小生成树的边标记为黑色：初始状态下
            所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将它权重最小的横切边标记为黑色。
            反复，直到标记了V-1条黑色边位置
    - 具体实现：
        1. Prim 算法：
            - 一开始树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点*且*不在树中
              的顶点且权重最小的边加入树中
            - 顶点：使用一个顶点索引的布尔数组marked[]
            - 边：队列或由顶点索引的Edge对象的数组edgeTo[], 其中edgeTo[v]为将v连接到树中的Edge对象
            - 横切边：使用一条优先队列来根据权重比较所有边
            - 时间复杂度，ElogE(最坏)
        2. Kruskal 算法:
            - 按照边的权重顺序(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，
              直到树中含有V - 1条边为止。又森林合并为一棵树
            - 优先队列将边按照权重排序，union-find来识别会形成环的边，队列用来保存最小生成树的所有边
            - 时间复杂度，ElogE(最坏), 但是慢于Prim

---
- 最短路径
    - 解决问题：找到从一个顶点到达另一个顶点的成本最小的路径
    - 定义：在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者
    - 性质：
        1. 路径是有向的
        2. 权重不一定等价于距离
        3. 并不是所有顶点都是可达的
        4. 负权重会使问题更复杂
        5. 最短路径会使问题更复杂
        6. 最短路径一般都是简单的
        7. 最短路劲不一定是唯一的
        8. 可能存在平行边和自环：忽略自环，假设平行边不存在
    - 最短路径树(SPT): 是一幅加权有向图的子图，它以s为起点，包含了s和从s可达的所有顶点。其中每条路径都是最短路径
    - 最短路径的API:
        1. 最短路径树的边：由顶点索引的DirectedEdge对象的父链接数组edgeTo[]
        2. 到达起点的距离：由顶点索引的数组distTo[]
    - 边的**松弛**: *放松*边`v->w`以为着检查从s到w的最短路径是否是先从`s->v`，再从`v->w`

        ```java
        private void relax(DirectedEdge e)
        {
            int v = e.from(), w = e.to();
            if (distTo[w] > distTo[v] + e.weight())   # 若w的路径长度 大于 边e的长度+边e的起点的路径
            {
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
            }
        }
        ```

    - 顶点的**松弛**：*放松*从一个给定顶点支出的所有边