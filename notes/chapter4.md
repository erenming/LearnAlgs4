- 有向图：

---
- 最小生成树
    - 加权图：是一种为每条边关联一个权值或是成本的图模型
    - 生成树：是图的一棵含有其所有顶点的无环连通子图
    - 最小生成树(MST)：是加权图的一棵权值最小的生成树
    - 切分：是将图的所有顶点分为两个非空且不重叠的两个集合
    - 横切边：是一条连接两个属于不同集合的顶点的边
    - 切分定理：在一幅加权图中，给定任意的切分，它的横切边中的*权重最小者*必然属于图的最小生成树
    - 最小生成树的贪心算法：
        1. 下面的这种方法会将含有V个顶点的任意加权连通图中属于最小生成树的边标记为黑色：初始状态下
            所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将它权重最小的横切边标记为黑色。
            反复，直到标记了V-1条黑色边位置
    - 具体实现：
        1. Prim 算法：
            - 一开始树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点*且*不在树中
              的顶点且权重最小的边加入树中
            - 顶点：使用一个顶点索引的布尔数组marked[]
            - 边：队列或由顶点索引的Edge对象的数组edgeTo[], 其中edgeTo[v]为将v连接到树中的Edge对象
            - 横切边：使用一条优先队列来根据权重比较所有边
            - 时间复杂度，ElogE(最坏)
        2. Kruskal 算法:
            - 按照边的权重顺序(从小到大)处理它们，将边加入最小生成树中，加入的边不会与已经加入的边构成环，
              直到树中含有V - 1条边为止。又森林合并为一棵树
            - 优先队列将边按照权重排序，union-find来识别会形成环的边，队列用来保存最小生成树的所有边
            - 时间复杂度，ElogE(最坏), 但是慢于Prim

---
- 最短路径
    - 解决问题：找到从一个顶点到达另一个顶点的成本最小的路径
    - 定义：在一幅加权有向图中，从顶点s到顶点t的最短路径是所有从s到t的路径中的权重最小者
    - 性质：
        1. 路径是有向的
        2. 权重不一定等价于距离
        3. 并不是所有顶点都是可达的
        4. 负权重会使问题更复杂
        5. 最短路径会使问题更复杂
        6. 最短路径一般都是简单的
        7. 最短路劲不一定是唯一的
        8. 可能存在平行边和自环：忽略自环，假设平行边不存在
    - 最短路径树(SPT): 是一幅加权有向图的子图，它以s为起点，包含了s和从s可达的所有顶点。其中每条路径都是最短路径
    - 最短路径的API:
        1. 最短路径树的边：由顶点索引的DirectedEdge对象的父链接数组edgeTo[]
        2. 到达起点的距离：由顶点索引的数组distTo[]
    - 边的**松弛**: *放松*边`v->w`以为着检查从s到w的最短路径是否是先从`s->v`，再从`v->w`

        ```java
        private void relax(DirectedEdge e)
        {
            int v = e.from(), w = e.to();
            if (distTo[w] > distTo[v] + e.weight())   # 若w的路径长度 大于 边e的长度+边e的起点的路径
            {
                distTo[w] = distTo[v] + e.weight();
                edgeTo[w] = e;
            }
        }
        ```

    - 顶点的**松弛**：*放松*从一个给定顶点支出的所有边