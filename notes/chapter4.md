- 无向图：
    - 无向图：由一组顶点和一组能够将两个顶点相连的边组成的
    - 特殊的图：
        1. 自环：一条连接一个顶点和其自身的边
        2. 平行边：连接同一对顶点的两条边
        3. 简单图：既没有平行边也没有自环的图
        4. 多重图：含有平行边的图
    - 当两个顶点通过一条边相连时，称这两个顶点是**相邻**的，并称这条边**依附**于这两个顶点
    - 度数：依附于某个顶点的边的总数
    - 子图：由一幅图的所有边的子集（以及它们依附的顶点）组成的图
    - 路径：由边顺序连接的一系列顶点
    - 简单路径：一条没有重复顶点的路径
    - 环：一条至少含有一条边且起点和终点相同的路径
    - 简单环：一条（除了顶点和终点必须乡土之外）不含有重复顶点和边的环
    - 当两个顶点之间存在一条连接双方的路径时，称一个顶点和另一个顶点是**连通的**
    - 连通图：如果从任意一个顶点**都存在**一条路径到达另一个任意顶点
    - 无环图：一种不包含环的图
    - 树是一幅无环连通图，互不相连的树组成的集合成为**森林**
    - 树的性质：
        1. 用一条边连接树中的任意两个顶点都会产生一个新的环
        2. 从树种删去一条边将会得到两棵独立的树
    - 连通图的生成树是它的一幅子图，它包含图的**所有顶点**且为一棵**树**；图的生成树森林是它的所有连通子图的生成树的集合
    - 二分图：将顶点分成两个不相交的集U和V，使得同一个集内的顶点不相邻（没有共同边）
    - 密度：已经连接的顶点占所有可能被连接的顶点对的比例。通常分为稀疏图和稠密图
    - 邻接表数组：一个以**顶点**为索引的列表数组，其中的每个**元素**都是和该顶点相邻的**顶点列表**
    - 深度优先搜索(DFS)：用一个递归方法来遍历所有节点。在访问一个顶点时：
        - 将它标记为已访问
        - 递归地访问它的所有没有被标记过的邻居节点
        - 应用：
            1. 寻找所有路径
            2. 寻找所有连通分量
            3. 判断是否为无环图
            4. 双色图问题
    - 广度优先搜索(BFS)：用一个队列来保存所有已被标记过但其邻接表还未检查过的顶点。先将起点加入队列，然后重复如下步骤
        - 取队列中的下一个顶点v并标记它
        - 将与v相邻的所有未标记过的顶点加入队列
        - 应用：
            1. 寻找单点最短路径
    - 符号图：
        - 实现：
            1. 一个符号表st, key为String(顶点名), value为int(索引)
            2. 一个数组keys[], 用作反向索引，保存每个顶点索引对应的顶点名
            3. 一个Graph对象G，它使用索引来引用图中顶点
---
- 有向图：
    - 定义：一幅有方向的图是由一组顶点和一组有方向的边组成的，每条有方向的边都连接着有序的一对顶点
    - 有向边：由第一个顶点**指出**并**指向**第二个顶点
    - 出度：某顶点指出的边的总数
    - 入度：指向某顶点的边的总数
    - 表示：邻接表
    - 取反：返回一个副本，但其中所有边的方向反转
    - 可达性：
        1. 单点可达性
        2. 多点可达性
    - 有向环检测：一旦找到一条有向边v -> w且w已存在于栈中，就找到了一个环
    - 应用：
        1. 标记-清除的垃圾收集
        2. 有向图的寻路
        3. 调度问题：
            - 优先级限制下的调度问题：给定一组任务根据优先级(诸如任务的执行时间，时耗等)安排它们的执行顺序
            - 拓扑排序：给定一幅有向图，将所有的顶点排序，使得所有的有向边均从排在前面的元素指向排在后面的元素
            - 解决步骤：
                1. 说明任务和优先级条件
                2. 不断检测并去除有向图中的所有环，以确保存在可行方案
                3. 使用拓扑排序解决调度问题
        4. 顶点的深度优先次序与拓补排序：
            - 基本思想：
                1. 深度优先搜索正好只会访问每个顶点一次
                2. 此时，如果将dfs()的参数顶点保存在某种数据结构中，遍历这个数据结构实际上就能访问图中的所有顶点，遍历的顺序取决于这个
                数据结构的性质以及在递归调用之前或之后保存。分为前序，后序，逆后序
            - 一幅有向无环图的拓扑结构即为所有顶点的逆后序排列
    - 强连通性：
        1. 如果两个顶点是互相可达的，则称它们为强连通的；如果一幅有向图中的任意两个顶点都是强连通的，则称这幅有向图也是强连通的
        2. 性质：
            - 自反性
            - 对称性
            - 传递性
        3. 强连通分量：由互相均为强连通的顶点的最大子集组成的集合
        4. 应用：
            - 分类问题：
                1. 例如网络，顶点为网页、边为超链接。连通分量可以将网页分为多个大小可接受的部分
        5. 计算方法:
            - Kosaraju算法：
                1. 在给定的一幅有向图G中，使用DepthFirstOrder来计算它的反向图G^R的逆后序排列
                2. 在G中进行标准的深度优先搜索，但是要按照刚才计算得到的顺序而非标准的书序来访问所有未被标记的顶点
                3. 在构造函数中，所有在同一递归dfs()调用中被访问到的顶点都在同一个*强连通分量*中，将它们按照和CC相同的方式识别出来
            - 评价：
                1. 预处理的时间和空间**与V+E成正比**且支持**常数**时间的有向图强连通性的查询
                
    - 两点的可达性：
        1. 传递闭包：
            - 有向图G的传递闭包是由相同的一组顶点组成的另一幅有向图，在传递闭包中存在一条从v指向w的边当且仅当在G中w是从v可达的
            
---
- 最小生成树
    - 加权图：是一种为每条边关联一个权值或是成本的图模型
    - 生成树：是图的一棵含有其所有顶点的无环连通子图
    - 最小生成树(MST)：是加权图的一棵权值最小的生成树
    - 切分：是将图的所有顶点分为两个非空且不重叠的两个集合
    - 横切边：是一条连接两个属于不同集合的顶点的边
    - 切分定理：在一幅加权图中，给定任意的切分，它的横切边中的*权重最小者*必然属于图的最小生成树
    - 最小生成树的贪心算法：
        1. 下面的这种方法会将含有V个顶点的任意加权连通图中属于最小生成树的边标记为黑色：出事状态下
            所有边均为灰色，找到一种切分，它产生的横切边均不为黑色。将它权重最小的横切边标记为黑色。
            反复，知道标记了V-1条黑色边位置
    - 具体实现：
        1. Prim 算法：
            - 一开始树只有一个顶点，然后会向它添加V-1条边，每次总是将下一条连接树中的顶点*且*不在树中
              的顶点且权重最小的边加入树中
            - 顶点：使用一个顶点索引的布尔数组marked[]
            - 边：队列或由顶点索引的Edge对象的数组edgeTo[], 其中edgeTo[v]为将v连接到树中的Edge对象
            - 横切边：使用一条优先队列来根据权重比较所有边