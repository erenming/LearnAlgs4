0. 数组：一种线性表数据结构。使用一组连续的内存空间，来存储一组具有相同类型的数据
    - 线性表：数据最多只有前后方向，例如数组，队列，栈等
    - 非线性：树，图等
    - 具有随机(random, 任意)访问的特性：通过下标，通过公式`a[i]_address = base_address + i * data_type_size`计算出地址，从而实现随机访问
    - 低效的插入和删除：
        1. 插入：最好O(1),最坏O(n),平均O(n)
            - 若数组无序，可将第k个元素移至末尾，然后将新的元素插入到第k个位置
        2. 删除：最好O(1) 最坏O(n) 平均O(n)
            - 多次删除集中在一起，提高删除效率：每次删除只是标记元素，当数组没有更多空间时再进行真正的删除。GC中的标记清除算法    
1. 背包：不支持从中删除元素的集合类型
    - 无序
    - API:
        ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20190305-223458@2x.png)
2. 队列：基于先进先出(FIFO)策略的集合类型
    - 保存数据的同时保存它们的相对顺序：使它们入列顺序和出列顺序相同
    - API:
        ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20190305-224038@2x.png)
    - 其他队列：
        1. 循环队列(可避免push时产生的搬移开销)
        2. 阻塞队列
        3. 并发队列
    - 应用场景：线程池，生产者消费者模型，消息队列
3. 栈(下压栈)：基于后进先出(LIFO)策略的集合类型
    - API:
        ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20190305-224509@2x.png)
    - 顺序栈：数组实现
    - 链式栈：链表实现
    - 应用：表达式求值，括号匹配，函数调用栈，浏览器前进后退
4. 链表：递归的数据结构，或者为空，或者指向一个节点(node)的引用，节点包括一个元素和一个指向另一个链表的引用
    - 节点：
    ```
    private class Node
    {
        Item item;
        Node next;
    }
    ```
    - 结构：
        ![xx](https://github.com/erenming/LearnAlgs4/raw/master/notes/images/WX20190305-225602@2x.png)
    - 表头的插入与删除:
        1. 插入：`Node oldfirst = first; first = new Node(); first.item = "xx"; first.next = oldfirst`
        2. 删除: `first = first.next;`
    - 表尾的插入:
        1. 插入：`oldlast.next = last;`
    - 其他位置的插入与删除: 应用双向链表，否则每次都得遍历链表
    - 应用：LRU缓存，回文字符串
    - 循环链表，双向循环链表
    - 如何写好？
        1. 理解指针和引用的含义
            - 将变量赋值给指针，实际上是将变量的地址赋值给指针；等同于指针中存储了这个变量的地址，指向这个变量
            - 变量存储数据(值)，指针存储数据(内存地址)
        2. 警惕指针丢失和内存泄露
        3. 利用哨兵简化实现难度
        4. 重点留意边界条件处理
        5. 举例画图，辅助思考
5. 解决问题之道：
    1. 定义API
    2. 根据特定的应用场景开发用例代码
    3. 描述一种数据结构，并在API所对应的抽象数据类型的实现中根据它定义类的实例变量
    4. 描述算法(实现一组操作的方式)，并根据它实现类中的实例方法
    5. 分析算法性能
6. 算法分析
    1. 大O时间复杂度表示法：又称渐进时间复杂度，简称时间复杂度
        - 定义：表示的是代码执行时间随数据规模增长的变化趋势
        - 分析方法
            1. 只关注循环执行次数最多的一段代码
            2. 加法法则：总复杂度等于量级最大的那段代码的复杂度。eg. `T(n)=max(O(f(n)), O(g(n)))`
            3. 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
        - 法则：
            1. 单段代码看高频：比如循环。
            2. 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
            3. 嵌套代码求乘积：比如递归、多重循环等
            4. 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。
        - 常见复杂度分析
            1. O(1): 一般情况下，只要算法中不存在循环、递归语句，即使成千上万代码，其时间复杂度为O(1)
            2. O(logn), O(nlogn): 较难分析
                - 例如等比数列的求和`i=1;while(i<n){i=i*2}`
            3. O(m+n), O(m*n): 由于m和n的规模，谁大谁小无法评估。加法法则修改，乘法法则有效
    2. 大O空间复杂度表示法：又称渐进空间复杂度
        - 定义：表示算法的存储空间与数据规模之间的增长关系
        - 分析方法：与空间类似
            1. 申请了常量阶O(n)的内存
            2. 申请了n阶O(n)的内存
    3. 最好情况时间复杂度：在最理想的情况下，执行这段代码的时间复杂度
    4. 最坏情况时间复杂度：在最糟糕的情况下，执行这段代码的时间复杂度
    5. 平均时间复杂度：用代码在所有情况下执行的次数的加权平均值表示
    6. 均摊时间复杂度：
        - 在代码执行的所有复杂度情况中绝大部分是低级别的复杂度，个别情况是高级别复杂度且发生具有时序关系时，
        可以将个别高级别复杂度均摊到低级别复杂度上。
        - 基本上均摊结果就等于低级别复杂度。
    7. 为何引入上述四种复杂度？
        - 因为同一段代码在不同情况下时间复杂度会出现量级差异时，为了更全面地描述，故引入